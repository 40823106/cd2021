var tipuesearch = {"pages": [{'title': 'About', 'text': 'This is  https://github.com/mdecourse/cmstemplate \n', 'tags': '', 'url': 'About.html'}, {'title': 'Stage1', 'text': '', 'tags': '', 'url': 'Stage1.html'}, {'title': 'WEEK1', 'text': '1.在小黑框中輸入leo\xa0 啟動 Leo Editor \n \n 2. 點選左上方file-open-outline-尋找pelican.leo檔案(若是沒有須自己建) \n \n 3.進入@path markdown的地方進行資料更改 \n ctrl+I是建立分頁 ctrl+R是建立另一主題 \n \n 4.進入Pelican 設定-@edit publishconf.py進行資料更改 \n \n 5.將資料更改完成即可進行推送 \n', 'tags': '', 'url': 'WEEK1.html'}, {'title': 'WEEK2', 'text': '與組員討論組題為倒車入庫，並完成第二周進度繪製零件圖並放入coppeliasim進行色調調整 \n https://youtu.be/Ycw1Y1WBLEk \n \n', 'tags': '', 'url': 'WEEK2.html'}, {'title': 'WEEK3', 'text': 'coppelia sim (V-rep)導入模型並模擬 \n 1.開啟 coppelia sim 點選 File-Import -Mesh... ，導入模型檔案(小組繪製模型為STL檔) \n \n 2.將導入的模型依照旗子母關係擺放 \n \n 3.新增節點，右鍵點選車輪 -Add -Joint - Revolute \n \n 4.將Joint移動至輪胎與輪軸銜接處 \n 5.調整車子設定，在零件的圖示上 用左鍵快速點及兩下 -點選 show dynamic properties dialog - 勾選 Body is respondable 和 Body is dynamic ( 車身和車輪 ) \n \n 6.調整Joint設定，在零件的圖示上 用左鍵快速點及兩下 -點選 show dynamic properties dialog - 勾選 Motor enabled 並給定速度 \n \n 7.調整後按下star simulation 進行模擬 \n \n', 'tags': '', 'url': 'WEEK3.html'}, {'title': 'WEEK4', 'text': '預定進度:上台報告 \n \n \n \n \n 討論 \n 要將各組的影片進行分類並且計算各組報告時間， \n 可手動計算也可利用程式分析ex:python count mp4 time \n', 'tags': '', 'url': 'WEEK4.html'}, {'title': 'Stage2', 'text': '', 'tags': '', 'url': 'Stage2.html'}, {'title': 'WEEK5', 'text': '我們這次的專案，決定以上一次未完成的排球扣球練習器進行改良；原本的主體只有單一的骨架與球軌，我們將改良成雙向作動與作動時間長的機構，讓排球可以順利滑動；並改良夾持的機構，改良成讓球在圓盤滾動一段時間後，球體的中心滑動到圓盤的中心點後自動掉落 \n 預定每週進度 \n W5 討論專題方向、 \n 每週進度 W6 繪製零件圖、在coppeliasim進行模擬並修正錯誤 \n W7 在coppeliasim進行模擬並修正錯誤、進行Heroku協統 \n W8 修正零件圖、在coppeliasim進行模擬並修正錯誤、準備pdf、製作reavel並分配上台報告內容 W9 上台報告 \n', 'tags': '', 'url': 'WEEK5.html'}, {'title': 'WEEK6', 'text': '預定進度:繪製零件圖、在coppeliasim進行模擬並修正錯誤 \n 骨架、球軌、接住球的部分 \n \n 轉盤及支撐軸，透過轉盤週期作旋轉動作讓球也成週期落下 \n \n 發球器組合圖 \n \n 組合圖 \n \n', 'tags': '', 'url': 'WEEK6.html'}, {'title': 'WEEK7', 'text': '1. 建立 Heroku 帳號，並且登記後要進入 @gm 帳號進行確認後才能開通 Heroku 帳號. \n \n 2. 建立 Heroku app \n 3. 下載 Heroku CLI \n 4. 修改命令搜尋路徑 \n \n 5. 以 git 進行提交推送 \n 先在小黑窗登入 \n heroku login \xa0 - i \n 再推送資料 \n heroku git:remote \xa0 - a\xa0 \n \xa0 \n', 'tags': '', 'url': 'WEEK7.html'}, {'title': 'WEEK8', 'text': 'coppeliasim進行模擬後發現轉盤太小會造成球一樣滾動因此將圓盤直徑加大 \n \n 模擬後發現須將底座挖圓盤軸的洞，不然組合圖放入coppeliasim時會自動視為一體，會導致無法驅動 \n 實際作動影片 \n \n', 'tags': '', 'url': 'WEEK8.html'}, {'title': 'WEEK9', 'text': '預定進度:上台報告 \n \n \n', 'tags': '', 'url': 'WEEK9.html'}, {'title': 'Stage3', 'text': '', 'tags': '', 'url': 'Stage3.html'}, {'title': 'WEEK10', 'text': '將stage2的資料作總整理 彙整至\xa0 https://github.com/mdecourse/cd2021/discussions/13 \n 進行stage3分組，創建網頁協同 site \n', 'tags': '', 'url': 'WEEK10.html'}, {'title': 'WEEK11', 'text': '1.建立新倉儲 \n \n 2.倉儲建立完成後，邀請別人進行協同 \n \n 3.將小組網頁資料下載 \n \n 4.下載完成後，更改config內容，將原本自己學號的網址改成原本倉儲的擁有者 \n \n 5.倉儲設定完成 \n \n \n \n', 'tags': '', 'url': 'WEEK11.html'}, {'title': 'WEEK12', 'text': '利用task1抽取學員，來進行直播 以小組的專題方向進行繪圖 \n \n', 'tags': '', 'url': 'WEEK12.html'}, {'title': 'WEEK13', 'text': '遠距離上課第一周，小組利用google meeting進行小組會議  \n', 'tags': '', 'url': 'WEEK13.html'}, {'title': 'WEEK14', 'text': '建立gitlab \n 1.搜尋gitlab sign up 點選第一個選項 GitLab.com account \n \n 2.填選個人資料(若是出現帳號已創建，可以先試著登陸看看，採用更改密碼的方式) \n 3.登入-Edit profile- SSH Keys \n \n 5. 打開puttygen.exe選load選取檔案 \n \n 6.選取ppk \n \n 7.複製鑰使串至網頁貼上 \n \n \n 8. 在編輯器開啟tmp/cd2021/.git/config修改 並推送 \n \n 9.cd tmp - cd cd2021 - git remoted add - git push gitlab \n', 'tags': '', 'url': 'WEEK14.html'}, {'title': 'WEEK15', 'text': "1.因為有取多同學帳號遭到封鎖，老師在課堂中講解除了利用gitlab也可以用 Fossil SCM 進行設計內容 \n \n 在 https://fossil.kmol.info:3443 中申請帳號 \n 建立一個空的倉儲 cd2021 \n 進入可攜系統中cd2021 輸入 git remote add fossil \xa0 http://fossil.kmol.inof:3000/帳號/cd2021.git \n git push fossil 即可成功 \n \n 2.進行影片翻譯 \n \n \n 翻譯如下: \n Here we have the same two link robot as we just looked at but this time we're going to solve it using an analytical approach, that is we're going to rely much more on algebra, particular linear algebra rather than geometry. \n 在這裡，我們有與剛才看到的相同的二連桿機構，但這次我們將使用分析方法來解決它，也就是說，我們將更多地依賴代數，特定的線性代數而不是幾何。 \n \n \xa0 We have an expression E, which is the homogeneous transformation which represents the pose of the robots endefector and we looked at this in the last lecture, we can write the endefector pose as a sequence of elementary homogeneous transformations. \n 我們有一個表達式 \xa0 E ，它是表示機械手臂位置的齊次變換，我們在上一課中看過這個，我們可以將機械手臂位置寫為一系列基本齊次變換。 \n \xa0 \n A rotation by q1, a translation along the X direction by a1, a rotation by q2 and then a translation in the X direction by a2. \n q1 旋轉，a 1 沿 x 方向平移，q 2 旋轉，然後a 2 沿 x 方向平移。 \n \xa0 \n If I expand this out, multiply all the transformations together, I get the expression shown here ; a three by three homogeneous transformation matrix representing the pose of the robot's endefector. \n 如果我將其展開，將所有變換相乘，就會得到此處所示的表達式；一個三乘三的齊次變換矩陣，表示機械手臂的最終位置。 \n \xa0 \n Now for this particular two link robot , we are only interested in the position of its endefector , it's X and Y co - ordinate and they are these two elements within the homogeneous transformation matrix , so I'm going to copy those out . \n 現在對於這個特殊的二連桿機構，我們只對它機械手臂的位置感興趣，它是 x 和 y 坐標，它們是齊次變換矩陣中的這兩個元素，所以我將把它們複製出來。 \n \xa0 \n So here again is our expression for X and Y and what we're going to do is a fairly common trick , we're going to square and add these two equations and I get a relationship that looks like this . \n 所以這裡又是我們對 x 和 y 的表達式，我們要做的是一個相當常見的技巧，我們要平方並添加這兩個方程，我得到一個看起來像這樣的關係式。 \n \n \xa0 Now I can solve for the joint angle q2 in terms of the endefector pose X and Y and the robot's constants a1 and a2. \n 現在我可以根據機械手臂位置 x 和 y 以及機器人的常數a 1 和a 2 來求解節點角度q 2 。 \n \xa0 \n Now what I'm going to do is apply the sum of angles identity . \n 現在我要做的是應用角度之和的特性。 \n \n I'm going to expand these terms, sin of q1 plus q2 or cos of q1 plus q2 and to make life a little bit easier, I'm going to make some substations, so where ever I had cos q2, I'm going to write c2 and where ever I had sine q2, I'm going to write s2. \n 我將展開這些項，sinq1+q 2 或 cosq1+ q 2 ，為了讓生活更輕鬆一點，我將建立一些部份，所以只要有 cosq2 ，我就會去取代c 2 並且在我有 sinq2 \xa0 的地方，取代為s 2 。 \n \xa0 \n It's a fairly common shorthand when people are looking at robot kinematic equations. And here are the equations after making those substitutions. \n 當人們解決機器人運動學方程時，這是一個相當常見的快速記法。這是進行這些替換後的方程式。 \n \xa0 \n Looking at these two equations, I can see that they fall into a very well known form and for that form there is a very well known solution. \n 看看這兩個方程，我可以看到它們屬於一個眾所周知的形式，對於這種形式，有一個眾所周知的解決方案。 \n \xa0 \n So I'm going to consider just one of the equations, the equation for Y and using our well known identity and it's solution, I can determine the values for the variables little a, little b and little c and once l've determined those, then I can just write down the solution for q1, which x is the equivalent of theta in this particular case. \n 所以我將只考慮其中一個方程式 Y ，使用我們眾所周知的恆等式和它的解，我可以確定變量 a 、 b 、 c \xa0 的值，一旦我確定了這些，然後我可以寫下q 1 的解決方案，在這種特殊情況下， x 相當於θ。 \n \xa0 \n Here again is our expression for q1, copied over from the previous slide and we may remember from earlier in our workings that we determined this particular relationship; X squared plus Y squared is equal to this particular complex expression. \n 這裡再次是我們對q 1 的表達式，從上一張幻燈片複製過來，我們可能還記得在我們工作的早期，我們確定了這種特殊關係； X 2+ Y 2 等於這個特定的複雜表達式。 \n \xa0 \n So I can substitute that in and do some simplification and I end up with this slightly less complex expression for q1. \n 因此，我可以將其替換並進行一些簡化，最終得到q1的這個稍微不那麼複雜的表達式。 \n \xa0 \n And it is the same expression that I got following the geometric approach in the previous section. \n 這與我在上一節中遵循幾何方法得到的表達式相同。 \n \n", 'tags': '', 'url': 'WEEK15.html'}, {'title': 'WEEK16', 'text': '1. Onshape 零組件繪製 \n 點選所繪製的零件-匯出 \n \n 並將檔案設定為STL檔-單位為mm-解析度為精細 \n \n 圖檔連結: https://cad.onshape.com/documents/15e83407d80dfa73cd0a79b4/w/708c36c519f886a7cf619237/e/8ab38e3393432ffc8ab92eae \n 2. 建立 CoppeliaSim 4.1.0 MTB robot 場景 \n 選擇File-Import-Mesh將檔案匯入 \n \n 選擇Edit-Grouping-Divide selected shapes 將檔案拆解方便定位軸 \n \n 點選零件Add-Comvex hull of selection將檔案曲線精密化 \n \n 點選零件-toggle shape 進行零件區域選取-選完點extract shape \n 這個方法可以將物件拆解產生新的區域 \n \n 先點軸-再點物體-點選移動物件-再點Position進行軸的定位 \n \n Force sensor是一個力傳感器可以同時測出三個方向和力矩 \n \n \n Revolute-選轉的軸 \n Prismatic-上下移動的軸 \n \n grippers可以點選吸盤 \n \n Cuboid為長方體 \n \n 2.建立 CoppeliaSim 4.1.0 MTB robot 場景 影片連結: https://youtu.be/1oJov8iJlvw W16_exam雲端連結: https://drive.google.com/drive/folders/1xdaI_OUvxgJNPPZhEz4KEd7s1sIHOJBq?usp=sharing \n 鍵盤控制的部分沒有完成，只有建立場景，鍵盤控制的程式碼還需要時間研究 3.手臂末端加入 components-gripper-suction pad 吸盤 影片連結 \n 4.逆向運動學函式 影片連結: \n \n \n \n \n \n \n \n function   moving(x,y) \n \xa0\xa0\xa0\xa0 a=0.5 \n \xa0\xa0\xa0\xa0 b=0.5 \n \xa0\xa0\xa0\xa0 c= math.pow (( math.pow (x,2)+ math.pow (y,2)),0.5) \n \xa0\xa0\xa0\xa0 s=(a+b+c)/2 \n \xa0\xa0\xa0\xa0 area= math.pow ((s*(s-a)*(s-b)*(s-c)),0.5) \n \xa0\xa0\xa0\xa0 h=area/(2*c) \n \xa0\xa0\xa0\xa0 deg1_base= math.atan (x/y) \n \xa0\xa0\xa0\xa0 if   x<0  and   y<0  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 deg1_base=deg1_base+ math.pi \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 deg1_tri= math.asin (h/a) \n \xa0\xa0\xa0\xa0 deg1=deg1_base+deg1_tri \n \xa0\xa0\xa0\xa0 deg2= math.pi -(0.5* math.pi -deg1_tri)- math.acos (h/b) \n \xa0\xa0\xa0\xa0 deg3=deg2-deg1 \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(AB,deg1) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(BC,-deg2) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(CD,deg3) \n end \n \xa0 \n function   sysCall_threadmain() \n \xa0\xa0\xa0\xa0 t=3 \n \xa0\xa0\xa0\xa0 AB=sim.getObjectHandle( \'AB\' ) \n \xa0\xa0\xa0\xa0 BC=sim.getObjectHandle( \'BC\' ) \n \xa0\xa0\xa0\xa0 CD=sim.getObjectHandle( \'CD\' ) \n \xa0\xa0\xa0\xa0 Z=sim.getObjectHandle( \'Z\' ) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(AB,0) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(BC,0) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(CD,0) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(Z,0) \n \xa0\xa0\xa0\xa0 sim.wait(t) \n \xa0\xa0\xa0\xa0 sim.setIntegerSignal( "pad_switch" ,1) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(Z,-0.09) \n \xa0\xa0\xa0\xa0 sim.wait(t) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(Z,0) \n \xa0\xa0\xa0\xa0 sim.wait(t) \n \xa0\xa0\xa0\xa0 moving(0.2,0.7) \n \xa0\xa0\xa0\xa0 sim.wait(t) \n \xa0\xa0\xa0\xa0 sim.setIntegerSignal( "pad_switch" ,0) \n \xa0\xa0\xa0\xa0 sim.wait(t) \n \xa0\xa0\xa0\xa0 sim.setIntegerSignal( "pad_switch" ,1) \n \xa0\xa0\xa0\xa0 sim.wait(t) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(Z,-0.09) \n \xa0\xa0\xa0\xa0 sim.wait(t) \n \xa0\xa0\xa0\xa0 sim.setJointTargetPosition(Z,0) \n \xa0\xa0\xa0\xa0 sim.wait(t) \n \xa0\xa0\xa0\xa0 moving(-0.3,-0.55) \n \xa0\xa0\xa0\xa0 sim.wait(t)\xa0\xa0  \n \xa0\xa0\xa0\xa0 sim.setIntegerSignal( "pad_switch" ,0) \n \xa0\xa0\xa0\xa0 \xa0 \n end \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n end \n \n \n \n \n \n AB.BC.CD.Z對應為軸的名稱 \n moving(0.2,0.7)、moving(-0.3,-0.55)為指定位置 \n \n \n 5.Python remote API 逆向運動學函式 操作影片: \n import   sim as vrep \n import   math \n import   random \n import   time \n import   math \n \xa0 \n def   moving(x,y): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 a = 0.5 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 b = 0.5 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 c = math. pow ((math. pow (x, 2 ) + math. pow (y, 2 )), 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 s = (a + b + c) / 2 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 area = math. pow ((s * (s - a) * (s - b) * (s - c)), 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 h = area / ( 2 * c) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 deg1_base = math.atan(x / y) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   x< 0   and   y< 0   : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 deg1_base = deg1_base + math.pi \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 deg1_tri = math.asin(h / a) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 deg1 = deg1_base + deg1_tri \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 deg2 = math.pi - ( 0.5 * math.pi - deg1_tri) - math.acos(h / b) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 deg3 = deg2 - deg1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID,joint1,deg1,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID,joint2, -   deg2,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID,joint3,deg3,opmode) \n \xa0 \n \xa0 \n \xa0 \n print   ( \'Start\' ) \n \xa0 \xa0 \n vrep.simxFinish( - 1 ) \n \xa0 \xa0 \n clientID  =   vrep.simxStart( \'127.0.0.1\' ,  19997 ,  True ,  True ,  5000 ,  5 ) \n \xa0\xa0 \xa0 \n if   clientID ! =   - 1 : \n \xa0\xa0\xa0\xa0 print   ( \'Connected to remote API server\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 res  =   vrep.simxAddStatusbarMessage( \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 clientID,  "This is teach by 40823214 " , \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0 if   res  not   in   (vrep.simx_return_ok, vrep.simx_return_novalue_flag): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "Could not add a message to the status bar." ) \n \xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 opmode  =   vrep.simx_opmode_oneshot_wait \n \xa0\xa0\xa0\xa0 STREAMING  =   vrep.simx_opmode_streaming \n \xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 vrep.simxStartSimulation(clientID, opmode) \n \xa0\xa0\xa0\xa0 ret,AB = vrep.simxGetObjectHandle(clientID, "AB" ,opmode) \n \xa0\xa0\xa0\xa0 ret,BC = vrep.simxGetObjectHandle(clientID, "BC" ,opmode) \n \xa0\xa0\xa0\xa0 ret,CD = vrep.simxGetObjectHandle(clientID, "CD" ,opmode) \n \xa0\xa0\xa0\xa0 ret,Z = vrep.simxGetObjectHandle(clientID, "Z" ,opmode) \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, AB , 0 ,opmode) \n \xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, BC , 0 ,opmode) \n \xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, CD , 0 ,opmode) \n \xa0\xa0\xa0\xa0 vrep.simxSetIntegerSignal(clientID, "pad_switch" , 1 ,opmode) \n \xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, Z , - 0.09 ,opmode) \n \xa0\xa0\xa0\xa0 time.sleep( 1 ) \n \xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, Z , 0 ,opmode) \n \xa0\xa0\xa0\xa0 while   True : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 moving( 0.2 , 0.7 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetIntegerSignal(clientID, "pad_switch" , 0 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetIntegerSignal(clientID, "pad_switch" , 1 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, Z , - 0.09 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, Z , 0 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 moving( - 0.3 , - 0.55 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetIntegerSignal(clientID, "pad_switch" , 0 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetIntegerSignal(clientID, "pad_switch" , 1 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, Z , - 0.09 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, Z , 0 ,opmode) \n \n 心得: \n 在這次考試前，我對onshape還不熟，因為平時都是使用inventor，藉由這次的考試讓我對這個免費的網頁繪圖更加的熟悉，再多次操作後，對其相關的功能運用更加的了解 \n 再先前小組分組中雖然有操作 CoppeliaSim的經驗，但當時使用到的機構比較少也沒接觸到程式的部分，但在這次的考試，我對於軟體的機構有更深入的認識，也因為製作的過程失敗很多次，所以我在最後成功組裝零件只需要花費不到10分鐘就可以完成，但仍有其他需要學習的機構 \n 但程式碼的部分是在同學分享的影片中學習到的，且還沒有很熟悉，希望自己可以增強程式方面的運用 \n 謝謝老師與同學的影片幫助，讓我在家裡也可以播放影片學習 \n', 'tags': '', 'url': 'WEEK16.html'}, {'title': 'Final Report', 'text': '這學期利用分組專案的方式，透過不同的專案可以激發出每位同學的想法，並且在討論的過程中學習表達自己的意見並接納不一樣的想法；利用分工的方式，每次都可以訓練自己負責不一樣的項目；在結果報告時學習如何協同產品設計簡報與結案報告，並利用利用 ssh 維護個人與分組倉儲與網站 \n 報告影片  \n', 'tags': '', 'url': 'Final Report.html'}]};